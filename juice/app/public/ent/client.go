// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"juice/app/public/ent/migrate"

	"juice/app/public/ent/userbaseinfo"
	"juice/app/public/ent/userfollowinfo"
	"juice/app/public/ent/userpassword"
	"juice/app/public/ent/videocollection"
	"juice/app/public/ent/videocomment"
	"juice/app/public/ent/videolike"
	"juice/app/public/ent/videometadatum"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// UserBaseInfo is the client for interacting with the UserBaseInfo builders.
	UserBaseInfo *UserBaseInfoClient
	// UserFollowInfo is the client for interacting with the UserFollowInfo builders.
	UserFollowInfo *UserFollowInfoClient
	// UserPassword is the client for interacting with the UserPassword builders.
	UserPassword *UserPasswordClient
	// VideoCollection is the client for interacting with the VideoCollection builders.
	VideoCollection *VideoCollectionClient
	// VideoComment is the client for interacting with the VideoComment builders.
	VideoComment *VideoCommentClient
	// VideoLike is the client for interacting with the VideoLike builders.
	VideoLike *VideoLikeClient
	// VideoMetadatum is the client for interacting with the VideoMetadatum builders.
	VideoMetadatum *VideoMetadatumClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.UserBaseInfo = NewUserBaseInfoClient(c.config)
	c.UserFollowInfo = NewUserFollowInfoClient(c.config)
	c.UserPassword = NewUserPasswordClient(c.config)
	c.VideoCollection = NewVideoCollectionClient(c.config)
	c.VideoComment = NewVideoCommentClient(c.config)
	c.VideoLike = NewVideoLikeClient(c.config)
	c.VideoMetadatum = NewVideoMetadatumClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		UserBaseInfo:    NewUserBaseInfoClient(cfg),
		UserFollowInfo:  NewUserFollowInfoClient(cfg),
		UserPassword:    NewUserPasswordClient(cfg),
		VideoCollection: NewVideoCollectionClient(cfg),
		VideoComment:    NewVideoCommentClient(cfg),
		VideoLike:       NewVideoLikeClient(cfg),
		VideoMetadatum:  NewVideoMetadatumClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		UserBaseInfo:    NewUserBaseInfoClient(cfg),
		UserFollowInfo:  NewUserFollowInfoClient(cfg),
		UserPassword:    NewUserPasswordClient(cfg),
		VideoCollection: NewVideoCollectionClient(cfg),
		VideoComment:    NewVideoCommentClient(cfg),
		VideoLike:       NewVideoLikeClient(cfg),
		VideoMetadatum:  NewVideoMetadatumClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		UserBaseInfo.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.UserBaseInfo, c.UserFollowInfo, c.UserPassword, c.VideoCollection,
		c.VideoComment, c.VideoLike, c.VideoMetadatum,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.UserBaseInfo, c.UserFollowInfo, c.UserPassword, c.VideoCollection,
		c.VideoComment, c.VideoLike, c.VideoMetadatum,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *UserBaseInfoMutation:
		return c.UserBaseInfo.mutate(ctx, m)
	case *UserFollowInfoMutation:
		return c.UserFollowInfo.mutate(ctx, m)
	case *UserPasswordMutation:
		return c.UserPassword.mutate(ctx, m)
	case *VideoCollectionMutation:
		return c.VideoCollection.mutate(ctx, m)
	case *VideoCommentMutation:
		return c.VideoComment.mutate(ctx, m)
	case *VideoLikeMutation:
		return c.VideoLike.mutate(ctx, m)
	case *VideoMetadatumMutation:
		return c.VideoMetadatum.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// UserBaseInfoClient is a client for the UserBaseInfo schema.
type UserBaseInfoClient struct {
	config
}

// NewUserBaseInfoClient returns a client for the UserBaseInfo from the given config.
func NewUserBaseInfoClient(c config) *UserBaseInfoClient {
	return &UserBaseInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userbaseinfo.Hooks(f(g(h())))`.
func (c *UserBaseInfoClient) Use(hooks ...Hook) {
	c.hooks.UserBaseInfo = append(c.hooks.UserBaseInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userbaseinfo.Intercept(f(g(h())))`.
func (c *UserBaseInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBaseInfo = append(c.inters.UserBaseInfo, interceptors...)
}

// Create returns a builder for creating a UserBaseInfo entity.
func (c *UserBaseInfoClient) Create() *UserBaseInfoCreate {
	mutation := newUserBaseInfoMutation(c.config, OpCreate)
	return &UserBaseInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBaseInfo entities.
func (c *UserBaseInfoClient) CreateBulk(builders ...*UserBaseInfoCreate) *UserBaseInfoCreateBulk {
	return &UserBaseInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBaseInfoClient) MapCreateBulk(slice any, setFunc func(*UserBaseInfoCreate, int)) *UserBaseInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBaseInfoCreateBulk{err: fmt.Errorf("calling to UserBaseInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBaseInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBaseInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBaseInfo.
func (c *UserBaseInfoClient) Update() *UserBaseInfoUpdate {
	mutation := newUserBaseInfoMutation(c.config, OpUpdate)
	return &UserBaseInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBaseInfoClient) UpdateOne(ubi *UserBaseInfo) *UserBaseInfoUpdateOne {
	mutation := newUserBaseInfoMutation(c.config, OpUpdateOne, withUserBaseInfo(ubi))
	return &UserBaseInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBaseInfoClient) UpdateOneID(id uint64) *UserBaseInfoUpdateOne {
	mutation := newUserBaseInfoMutation(c.config, OpUpdateOne, withUserBaseInfoID(id))
	return &UserBaseInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBaseInfo.
func (c *UserBaseInfoClient) Delete() *UserBaseInfoDelete {
	mutation := newUserBaseInfoMutation(c.config, OpDelete)
	return &UserBaseInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBaseInfoClient) DeleteOne(ubi *UserBaseInfo) *UserBaseInfoDeleteOne {
	return c.DeleteOneID(ubi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBaseInfoClient) DeleteOneID(id uint64) *UserBaseInfoDeleteOne {
	builder := c.Delete().Where(userbaseinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBaseInfoDeleteOne{builder}
}

// Query returns a query builder for UserBaseInfo.
func (c *UserBaseInfoClient) Query() *UserBaseInfoQuery {
	return &UserBaseInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBaseInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBaseInfo entity by its id.
func (c *UserBaseInfoClient) Get(ctx context.Context, id uint64) (*UserBaseInfo, error) {
	return c.Query().Where(userbaseinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBaseInfoClient) GetX(ctx context.Context, id uint64) *UserBaseInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserBaseInfoClient) Hooks() []Hook {
	return c.hooks.UserBaseInfo
}

// Interceptors returns the client interceptors.
func (c *UserBaseInfoClient) Interceptors() []Interceptor {
	return c.inters.UserBaseInfo
}

func (c *UserBaseInfoClient) mutate(ctx context.Context, m *UserBaseInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBaseInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBaseInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBaseInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBaseInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBaseInfo mutation op: %q", m.Op())
	}
}

// UserFollowInfoClient is a client for the UserFollowInfo schema.
type UserFollowInfoClient struct {
	config
}

// NewUserFollowInfoClient returns a client for the UserFollowInfo from the given config.
func NewUserFollowInfoClient(c config) *UserFollowInfoClient {
	return &UserFollowInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowinfo.Hooks(f(g(h())))`.
func (c *UserFollowInfoClient) Use(hooks ...Hook) {
	c.hooks.UserFollowInfo = append(c.hooks.UserFollowInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowinfo.Intercept(f(g(h())))`.
func (c *UserFollowInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowInfo = append(c.inters.UserFollowInfo, interceptors...)
}

// Create returns a builder for creating a UserFollowInfo entity.
func (c *UserFollowInfoClient) Create() *UserFollowInfoCreate {
	mutation := newUserFollowInfoMutation(c.config, OpCreate)
	return &UserFollowInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowInfo entities.
func (c *UserFollowInfoClient) CreateBulk(builders ...*UserFollowInfoCreate) *UserFollowInfoCreateBulk {
	return &UserFollowInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserFollowInfoClient) MapCreateBulk(slice any, setFunc func(*UserFollowInfoCreate, int)) *UserFollowInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserFollowInfoCreateBulk{err: fmt.Errorf("calling to UserFollowInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserFollowInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserFollowInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowInfo.
func (c *UserFollowInfoClient) Update() *UserFollowInfoUpdate {
	mutation := newUserFollowInfoMutation(c.config, OpUpdate)
	return &UserFollowInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowInfoClient) UpdateOne(ufi *UserFollowInfo) *UserFollowInfoUpdateOne {
	mutation := newUserFollowInfoMutation(c.config, OpUpdateOne, withUserFollowInfo(ufi))
	return &UserFollowInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowInfoClient) UpdateOneID(id uint64) *UserFollowInfoUpdateOne {
	mutation := newUserFollowInfoMutation(c.config, OpUpdateOne, withUserFollowInfoID(id))
	return &UserFollowInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowInfo.
func (c *UserFollowInfoClient) Delete() *UserFollowInfoDelete {
	mutation := newUserFollowInfoMutation(c.config, OpDelete)
	return &UserFollowInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowInfoClient) DeleteOne(ufi *UserFollowInfo) *UserFollowInfoDeleteOne {
	return c.DeleteOneID(ufi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowInfoClient) DeleteOneID(id uint64) *UserFollowInfoDeleteOne {
	builder := c.Delete().Where(userfollowinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowInfoDeleteOne{builder}
}

// Query returns a query builder for UserFollowInfo.
func (c *UserFollowInfoClient) Query() *UserFollowInfoQuery {
	return &UserFollowInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowInfo entity by its id.
func (c *UserFollowInfoClient) Get(ctx context.Context, id uint64) (*UserFollowInfo, error) {
	return c.Query().Where(userfollowinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowInfoClient) GetX(ctx context.Context, id uint64) *UserFollowInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserFollowInfoClient) Hooks() []Hook {
	return c.hooks.UserFollowInfo
}

// Interceptors returns the client interceptors.
func (c *UserFollowInfoClient) Interceptors() []Interceptor {
	return c.inters.UserFollowInfo
}

func (c *UserFollowInfoClient) mutate(ctx context.Context, m *UserFollowInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowInfo mutation op: %q", m.Op())
	}
}

// UserPasswordClient is a client for the UserPassword schema.
type UserPasswordClient struct {
	config
}

// NewUserPasswordClient returns a client for the UserPassword from the given config.
func NewUserPasswordClient(c config) *UserPasswordClient {
	return &UserPasswordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpassword.Hooks(f(g(h())))`.
func (c *UserPasswordClient) Use(hooks ...Hook) {
	c.hooks.UserPassword = append(c.hooks.UserPassword, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpassword.Intercept(f(g(h())))`.
func (c *UserPasswordClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPassword = append(c.inters.UserPassword, interceptors...)
}

// Create returns a builder for creating a UserPassword entity.
func (c *UserPasswordClient) Create() *UserPasswordCreate {
	mutation := newUserPasswordMutation(c.config, OpCreate)
	return &UserPasswordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPassword entities.
func (c *UserPasswordClient) CreateBulk(builders ...*UserPasswordCreate) *UserPasswordCreateBulk {
	return &UserPasswordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserPasswordClient) MapCreateBulk(slice any, setFunc func(*UserPasswordCreate, int)) *UserPasswordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserPasswordCreateBulk{err: fmt.Errorf("calling to UserPasswordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserPasswordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserPasswordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPassword.
func (c *UserPasswordClient) Update() *UserPasswordUpdate {
	mutation := newUserPasswordMutation(c.config, OpUpdate)
	return &UserPasswordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPasswordClient) UpdateOne(up *UserPassword) *UserPasswordUpdateOne {
	mutation := newUserPasswordMutation(c.config, OpUpdateOne, withUserPassword(up))
	return &UserPasswordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPasswordClient) UpdateOneID(id uint64) *UserPasswordUpdateOne {
	mutation := newUserPasswordMutation(c.config, OpUpdateOne, withUserPasswordID(id))
	return &UserPasswordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPassword.
func (c *UserPasswordClient) Delete() *UserPasswordDelete {
	mutation := newUserPasswordMutation(c.config, OpDelete)
	return &UserPasswordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPasswordClient) DeleteOne(up *UserPassword) *UserPasswordDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPasswordClient) DeleteOneID(id uint64) *UserPasswordDeleteOne {
	builder := c.Delete().Where(userpassword.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPasswordDeleteOne{builder}
}

// Query returns a query builder for UserPassword.
func (c *UserPasswordClient) Query() *UserPasswordQuery {
	return &UserPasswordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPassword},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPassword entity by its id.
func (c *UserPasswordClient) Get(ctx context.Context, id uint64) (*UserPassword, error) {
	return c.Query().Where(userpassword.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPasswordClient) GetX(ctx context.Context, id uint64) *UserPassword {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserPasswordClient) Hooks() []Hook {
	return c.hooks.UserPassword
}

// Interceptors returns the client interceptors.
func (c *UserPasswordClient) Interceptors() []Interceptor {
	return c.inters.UserPassword
}

func (c *UserPasswordClient) mutate(ctx context.Context, m *UserPasswordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPasswordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPasswordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPasswordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPasswordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserPassword mutation op: %q", m.Op())
	}
}

// VideoCollectionClient is a client for the VideoCollection schema.
type VideoCollectionClient struct {
	config
}

// NewVideoCollectionClient returns a client for the VideoCollection from the given config.
func NewVideoCollectionClient(c config) *VideoCollectionClient {
	return &VideoCollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videocollection.Hooks(f(g(h())))`.
func (c *VideoCollectionClient) Use(hooks ...Hook) {
	c.hooks.VideoCollection = append(c.hooks.VideoCollection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videocollection.Intercept(f(g(h())))`.
func (c *VideoCollectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.VideoCollection = append(c.inters.VideoCollection, interceptors...)
}

// Create returns a builder for creating a VideoCollection entity.
func (c *VideoCollectionClient) Create() *VideoCollectionCreate {
	mutation := newVideoCollectionMutation(c.config, OpCreate)
	return &VideoCollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VideoCollection entities.
func (c *VideoCollectionClient) CreateBulk(builders ...*VideoCollectionCreate) *VideoCollectionCreateBulk {
	return &VideoCollectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoCollectionClient) MapCreateBulk(slice any, setFunc func(*VideoCollectionCreate, int)) *VideoCollectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoCollectionCreateBulk{err: fmt.Errorf("calling to VideoCollectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoCollectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoCollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VideoCollection.
func (c *VideoCollectionClient) Update() *VideoCollectionUpdate {
	mutation := newVideoCollectionMutation(c.config, OpUpdate)
	return &VideoCollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoCollectionClient) UpdateOne(vc *VideoCollection) *VideoCollectionUpdateOne {
	mutation := newVideoCollectionMutation(c.config, OpUpdateOne, withVideoCollection(vc))
	return &VideoCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoCollectionClient) UpdateOneID(id uint64) *VideoCollectionUpdateOne {
	mutation := newVideoCollectionMutation(c.config, OpUpdateOne, withVideoCollectionID(id))
	return &VideoCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VideoCollection.
func (c *VideoCollectionClient) Delete() *VideoCollectionDelete {
	mutation := newVideoCollectionMutation(c.config, OpDelete)
	return &VideoCollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoCollectionClient) DeleteOne(vc *VideoCollection) *VideoCollectionDeleteOne {
	return c.DeleteOneID(vc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoCollectionClient) DeleteOneID(id uint64) *VideoCollectionDeleteOne {
	builder := c.Delete().Where(videocollection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoCollectionDeleteOne{builder}
}

// Query returns a query builder for VideoCollection.
func (c *VideoCollectionClient) Query() *VideoCollectionQuery {
	return &VideoCollectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideoCollection},
		inters: c.Interceptors(),
	}
}

// Get returns a VideoCollection entity by its id.
func (c *VideoCollectionClient) Get(ctx context.Context, id uint64) (*VideoCollection, error) {
	return c.Query().Where(videocollection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoCollectionClient) GetX(ctx context.Context, id uint64) *VideoCollection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VideoCollectionClient) Hooks() []Hook {
	return c.hooks.VideoCollection
}

// Interceptors returns the client interceptors.
func (c *VideoCollectionClient) Interceptors() []Interceptor {
	return c.inters.VideoCollection
}

func (c *VideoCollectionClient) mutate(ctx context.Context, m *VideoCollectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoCollectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoCollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoCollectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VideoCollection mutation op: %q", m.Op())
	}
}

// VideoCommentClient is a client for the VideoComment schema.
type VideoCommentClient struct {
	config
}

// NewVideoCommentClient returns a client for the VideoComment from the given config.
func NewVideoCommentClient(c config) *VideoCommentClient {
	return &VideoCommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videocomment.Hooks(f(g(h())))`.
func (c *VideoCommentClient) Use(hooks ...Hook) {
	c.hooks.VideoComment = append(c.hooks.VideoComment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videocomment.Intercept(f(g(h())))`.
func (c *VideoCommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.VideoComment = append(c.inters.VideoComment, interceptors...)
}

// Create returns a builder for creating a VideoComment entity.
func (c *VideoCommentClient) Create() *VideoCommentCreate {
	mutation := newVideoCommentMutation(c.config, OpCreate)
	return &VideoCommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VideoComment entities.
func (c *VideoCommentClient) CreateBulk(builders ...*VideoCommentCreate) *VideoCommentCreateBulk {
	return &VideoCommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoCommentClient) MapCreateBulk(slice any, setFunc func(*VideoCommentCreate, int)) *VideoCommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoCommentCreateBulk{err: fmt.Errorf("calling to VideoCommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoCommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoCommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VideoComment.
func (c *VideoCommentClient) Update() *VideoCommentUpdate {
	mutation := newVideoCommentMutation(c.config, OpUpdate)
	return &VideoCommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoCommentClient) UpdateOne(vc *VideoComment) *VideoCommentUpdateOne {
	mutation := newVideoCommentMutation(c.config, OpUpdateOne, withVideoComment(vc))
	return &VideoCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoCommentClient) UpdateOneID(id uint64) *VideoCommentUpdateOne {
	mutation := newVideoCommentMutation(c.config, OpUpdateOne, withVideoCommentID(id))
	return &VideoCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VideoComment.
func (c *VideoCommentClient) Delete() *VideoCommentDelete {
	mutation := newVideoCommentMutation(c.config, OpDelete)
	return &VideoCommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoCommentClient) DeleteOne(vc *VideoComment) *VideoCommentDeleteOne {
	return c.DeleteOneID(vc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoCommentClient) DeleteOneID(id uint64) *VideoCommentDeleteOne {
	builder := c.Delete().Where(videocomment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoCommentDeleteOne{builder}
}

// Query returns a query builder for VideoComment.
func (c *VideoCommentClient) Query() *VideoCommentQuery {
	return &VideoCommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideoComment},
		inters: c.Interceptors(),
	}
}

// Get returns a VideoComment entity by its id.
func (c *VideoCommentClient) Get(ctx context.Context, id uint64) (*VideoComment, error) {
	return c.Query().Where(videocomment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoCommentClient) GetX(ctx context.Context, id uint64) *VideoComment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VideoCommentClient) Hooks() []Hook {
	return c.hooks.VideoComment
}

// Interceptors returns the client interceptors.
func (c *VideoCommentClient) Interceptors() []Interceptor {
	return c.inters.VideoComment
}

func (c *VideoCommentClient) mutate(ctx context.Context, m *VideoCommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoCommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoCommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoCommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VideoComment mutation op: %q", m.Op())
	}
}

// VideoLikeClient is a client for the VideoLike schema.
type VideoLikeClient struct {
	config
}

// NewVideoLikeClient returns a client for the VideoLike from the given config.
func NewVideoLikeClient(c config) *VideoLikeClient {
	return &VideoLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videolike.Hooks(f(g(h())))`.
func (c *VideoLikeClient) Use(hooks ...Hook) {
	c.hooks.VideoLike = append(c.hooks.VideoLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videolike.Intercept(f(g(h())))`.
func (c *VideoLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.VideoLike = append(c.inters.VideoLike, interceptors...)
}

// Create returns a builder for creating a VideoLike entity.
func (c *VideoLikeClient) Create() *VideoLikeCreate {
	mutation := newVideoLikeMutation(c.config, OpCreate)
	return &VideoLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VideoLike entities.
func (c *VideoLikeClient) CreateBulk(builders ...*VideoLikeCreate) *VideoLikeCreateBulk {
	return &VideoLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoLikeClient) MapCreateBulk(slice any, setFunc func(*VideoLikeCreate, int)) *VideoLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoLikeCreateBulk{err: fmt.Errorf("calling to VideoLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VideoLike.
func (c *VideoLikeClient) Update() *VideoLikeUpdate {
	mutation := newVideoLikeMutation(c.config, OpUpdate)
	return &VideoLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoLikeClient) UpdateOne(vl *VideoLike) *VideoLikeUpdateOne {
	mutation := newVideoLikeMutation(c.config, OpUpdateOne, withVideoLike(vl))
	return &VideoLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoLikeClient) UpdateOneID(id uint64) *VideoLikeUpdateOne {
	mutation := newVideoLikeMutation(c.config, OpUpdateOne, withVideoLikeID(id))
	return &VideoLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VideoLike.
func (c *VideoLikeClient) Delete() *VideoLikeDelete {
	mutation := newVideoLikeMutation(c.config, OpDelete)
	return &VideoLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoLikeClient) DeleteOne(vl *VideoLike) *VideoLikeDeleteOne {
	return c.DeleteOneID(vl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoLikeClient) DeleteOneID(id uint64) *VideoLikeDeleteOne {
	builder := c.Delete().Where(videolike.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoLikeDeleteOne{builder}
}

// Query returns a query builder for VideoLike.
func (c *VideoLikeClient) Query() *VideoLikeQuery {
	return &VideoLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideoLike},
		inters: c.Interceptors(),
	}
}

// Get returns a VideoLike entity by its id.
func (c *VideoLikeClient) Get(ctx context.Context, id uint64) (*VideoLike, error) {
	return c.Query().Where(videolike.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoLikeClient) GetX(ctx context.Context, id uint64) *VideoLike {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VideoLikeClient) Hooks() []Hook {
	return c.hooks.VideoLike
}

// Interceptors returns the client interceptors.
func (c *VideoLikeClient) Interceptors() []Interceptor {
	return c.inters.VideoLike
}

func (c *VideoLikeClient) mutate(ctx context.Context, m *VideoLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VideoLike mutation op: %q", m.Op())
	}
}

// VideoMetadatumClient is a client for the VideoMetadatum schema.
type VideoMetadatumClient struct {
	config
}

// NewVideoMetadatumClient returns a client for the VideoMetadatum from the given config.
func NewVideoMetadatumClient(c config) *VideoMetadatumClient {
	return &VideoMetadatumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videometadatum.Hooks(f(g(h())))`.
func (c *VideoMetadatumClient) Use(hooks ...Hook) {
	c.hooks.VideoMetadatum = append(c.hooks.VideoMetadatum, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videometadatum.Intercept(f(g(h())))`.
func (c *VideoMetadatumClient) Intercept(interceptors ...Interceptor) {
	c.inters.VideoMetadatum = append(c.inters.VideoMetadatum, interceptors...)
}

// Create returns a builder for creating a VideoMetadatum entity.
func (c *VideoMetadatumClient) Create() *VideoMetadatumCreate {
	mutation := newVideoMetadatumMutation(c.config, OpCreate)
	return &VideoMetadatumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VideoMetadatum entities.
func (c *VideoMetadatumClient) CreateBulk(builders ...*VideoMetadatumCreate) *VideoMetadatumCreateBulk {
	return &VideoMetadatumCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoMetadatumClient) MapCreateBulk(slice any, setFunc func(*VideoMetadatumCreate, int)) *VideoMetadatumCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoMetadatumCreateBulk{err: fmt.Errorf("calling to VideoMetadatumClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoMetadatumCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoMetadatumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VideoMetadatum.
func (c *VideoMetadatumClient) Update() *VideoMetadatumUpdate {
	mutation := newVideoMetadatumMutation(c.config, OpUpdate)
	return &VideoMetadatumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoMetadatumClient) UpdateOne(vm *VideoMetadatum) *VideoMetadatumUpdateOne {
	mutation := newVideoMetadatumMutation(c.config, OpUpdateOne, withVideoMetadatum(vm))
	return &VideoMetadatumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoMetadatumClient) UpdateOneID(id uint64) *VideoMetadatumUpdateOne {
	mutation := newVideoMetadatumMutation(c.config, OpUpdateOne, withVideoMetadatumID(id))
	return &VideoMetadatumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VideoMetadatum.
func (c *VideoMetadatumClient) Delete() *VideoMetadatumDelete {
	mutation := newVideoMetadatumMutation(c.config, OpDelete)
	return &VideoMetadatumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoMetadatumClient) DeleteOne(vm *VideoMetadatum) *VideoMetadatumDeleteOne {
	return c.DeleteOneID(vm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoMetadatumClient) DeleteOneID(id uint64) *VideoMetadatumDeleteOne {
	builder := c.Delete().Where(videometadatum.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoMetadatumDeleteOne{builder}
}

// Query returns a query builder for VideoMetadatum.
func (c *VideoMetadatumClient) Query() *VideoMetadatumQuery {
	return &VideoMetadatumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideoMetadatum},
		inters: c.Interceptors(),
	}
}

// Get returns a VideoMetadatum entity by its id.
func (c *VideoMetadatumClient) Get(ctx context.Context, id uint64) (*VideoMetadatum, error) {
	return c.Query().Where(videometadatum.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoMetadatumClient) GetX(ctx context.Context, id uint64) *VideoMetadatum {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VideoMetadatumClient) Hooks() []Hook {
	return c.hooks.VideoMetadatum
}

// Interceptors returns the client interceptors.
func (c *VideoMetadatumClient) Interceptors() []Interceptor {
	return c.inters.VideoMetadatum
}

func (c *VideoMetadatumClient) mutate(ctx context.Context, m *VideoMetadatumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoMetadatumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoMetadatumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoMetadatumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoMetadatumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VideoMetadatum mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		UserBaseInfo, UserFollowInfo, UserPassword, VideoCollection, VideoComment,
		VideoLike, VideoMetadatum []ent.Hook
	}
	inters struct {
		UserBaseInfo, UserFollowInfo, UserPassword, VideoCollection, VideoComment,
		VideoLike, VideoMetadatum []ent.Interceptor
	}
)
