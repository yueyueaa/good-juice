// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"juice/app/user/internal/data/ent/predicate"
	"juice/app/user/internal/data/ent/userbaseinfo"
	"juice/app/user/internal/data/ent/userfollowinfo"
	"juice/app/user/internal/data/ent/userpassword"
	"juice/app/user/internal/data/ent/videocollection"
	"juice/app/user/internal/data/ent/videocomment"
	"juice/app/user/internal/data/ent/videolike"
	"juice/app/user/internal/data/ent/videometadatum"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeUserBaseInfo    = "UserBaseInfo"
	TypeUserFollowInfo  = "UserFollowInfo"
	TypeUserPassword    = "UserPassword"
	TypeVideoCollection = "VideoCollection"
	TypeVideoComment    = "VideoComment"
	TypeVideoLike       = "VideoLike"
	TypeVideoMetadatum  = "VideoMetadatum"
)

// UserBaseInfoMutation represents an operation that mutates the UserBaseInfo nodes in the graph.
type UserBaseInfoMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	user_id                *uint64
	adduser_id             *int64
	username               *string
	sex                    *int8
	addsex                 *int8
	birth                  *time.Time
	area                   *int32
	addarea                *int32
	user_profile           *string
	user_profile_photo_url *string
	follow_count           *int32
	addfollow_count        *int32
	fan_count              *int32
	addfan_count           *int32
	create_time            *time.Time
	update_time            *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*UserBaseInfo, error)
	predicates             []predicate.UserBaseInfo
}

var _ ent.Mutation = (*UserBaseInfoMutation)(nil)

// userbaseinfoOption allows management of the mutation configuration using functional options.
type userbaseinfoOption func(*UserBaseInfoMutation)

// newUserBaseInfoMutation creates new mutation for the UserBaseInfo entity.
func newUserBaseInfoMutation(c config, op Op, opts ...userbaseinfoOption) *UserBaseInfoMutation {
	m := &UserBaseInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBaseInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBaseInfoID sets the ID field of the mutation.
func withUserBaseInfoID(id int) userbaseinfoOption {
	return func(m *UserBaseInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBaseInfo
		)
		m.oldValue = func(ctx context.Context) (*UserBaseInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBaseInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBaseInfo sets the old UserBaseInfo of the mutation.
func withUserBaseInfo(node *UserBaseInfo) userbaseinfoOption {
	return func(m *UserBaseInfoMutation) {
		m.oldValue = func(context.Context) (*UserBaseInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBaseInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBaseInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBaseInfo entities.
func (m *UserBaseInfoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBaseInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBaseInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBaseInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserBaseInfoMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBaseInfoMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserBaseInfoMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserBaseInfoMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBaseInfoMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetUsername sets the "username" field.
func (m *UserBaseInfoMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserBaseInfoMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserBaseInfoMutation) ResetUsername() {
	m.username = nil
}

// SetSex sets the "sex" field.
func (m *UserBaseInfoMutation) SetSex(i int8) {
	m.sex = &i
	m.addsex = nil
}

// Sex returns the value of the "sex" field in the mutation.
func (m *UserBaseInfoMutation) Sex() (r int8, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldSex(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// AddSex adds i to the "sex" field.
func (m *UserBaseInfoMutation) AddSex(i int8) {
	if m.addsex != nil {
		*m.addsex += i
	} else {
		m.addsex = &i
	}
}

// AddedSex returns the value that was added to the "sex" field in this mutation.
func (m *UserBaseInfoMutation) AddedSex() (r int8, exists bool) {
	v := m.addsex
	if v == nil {
		return
	}
	return *v, true
}

// ResetSex resets all changes to the "sex" field.
func (m *UserBaseInfoMutation) ResetSex() {
	m.sex = nil
	m.addsex = nil
}

// SetBirth sets the "birth" field.
func (m *UserBaseInfoMutation) SetBirth(t time.Time) {
	m.birth = &t
}

// Birth returns the value of the "birth" field in the mutation.
func (m *UserBaseInfoMutation) Birth() (r time.Time, exists bool) {
	v := m.birth
	if v == nil {
		return
	}
	return *v, true
}

// OldBirth returns the old "birth" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirth: %w", err)
	}
	return oldValue.Birth, nil
}

// ClearBirth clears the value of the "birth" field.
func (m *UserBaseInfoMutation) ClearBirth() {
	m.birth = nil
	m.clearedFields[userbaseinfo.FieldBirth] = struct{}{}
}

// BirthCleared returns if the "birth" field was cleared in this mutation.
func (m *UserBaseInfoMutation) BirthCleared() bool {
	_, ok := m.clearedFields[userbaseinfo.FieldBirth]
	return ok
}

// ResetBirth resets all changes to the "birth" field.
func (m *UserBaseInfoMutation) ResetBirth() {
	m.birth = nil
	delete(m.clearedFields, userbaseinfo.FieldBirth)
}

// SetArea sets the "area" field.
func (m *UserBaseInfoMutation) SetArea(i int32) {
	m.area = &i
	m.addarea = nil
}

// Area returns the value of the "area" field in the mutation.
func (m *UserBaseInfoMutation) Area() (r int32, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldArea(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// AddArea adds i to the "area" field.
func (m *UserBaseInfoMutation) AddArea(i int32) {
	if m.addarea != nil {
		*m.addarea += i
	} else {
		m.addarea = &i
	}
}

// AddedArea returns the value that was added to the "area" field in this mutation.
func (m *UserBaseInfoMutation) AddedArea() (r int32, exists bool) {
	v := m.addarea
	if v == nil {
		return
	}
	return *v, true
}

// ResetArea resets all changes to the "area" field.
func (m *UserBaseInfoMutation) ResetArea() {
	m.area = nil
	m.addarea = nil
}

// SetUserProfile sets the "user_profile" field.
func (m *UserBaseInfoMutation) SetUserProfile(s string) {
	m.user_profile = &s
}

// UserProfile returns the value of the "user_profile" field in the mutation.
func (m *UserBaseInfoMutation) UserProfile() (r string, exists bool) {
	v := m.user_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldUserProfile returns the old "user_profile" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldUserProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserProfile: %w", err)
	}
	return oldValue.UserProfile, nil
}

// ClearUserProfile clears the value of the "user_profile" field.
func (m *UserBaseInfoMutation) ClearUserProfile() {
	m.user_profile = nil
	m.clearedFields[userbaseinfo.FieldUserProfile] = struct{}{}
}

// UserProfileCleared returns if the "user_profile" field was cleared in this mutation.
func (m *UserBaseInfoMutation) UserProfileCleared() bool {
	_, ok := m.clearedFields[userbaseinfo.FieldUserProfile]
	return ok
}

// ResetUserProfile resets all changes to the "user_profile" field.
func (m *UserBaseInfoMutation) ResetUserProfile() {
	m.user_profile = nil
	delete(m.clearedFields, userbaseinfo.FieldUserProfile)
}

// SetUserProfilePhotoURL sets the "user_profile_photo_url" field.
func (m *UserBaseInfoMutation) SetUserProfilePhotoURL(s string) {
	m.user_profile_photo_url = &s
}

// UserProfilePhotoURL returns the value of the "user_profile_photo_url" field in the mutation.
func (m *UserBaseInfoMutation) UserProfilePhotoURL() (r string, exists bool) {
	v := m.user_profile_photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldUserProfilePhotoURL returns the old "user_profile_photo_url" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldUserProfilePhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserProfilePhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserProfilePhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserProfilePhotoURL: %w", err)
	}
	return oldValue.UserProfilePhotoURL, nil
}

// ClearUserProfilePhotoURL clears the value of the "user_profile_photo_url" field.
func (m *UserBaseInfoMutation) ClearUserProfilePhotoURL() {
	m.user_profile_photo_url = nil
	m.clearedFields[userbaseinfo.FieldUserProfilePhotoURL] = struct{}{}
}

// UserProfilePhotoURLCleared returns if the "user_profile_photo_url" field was cleared in this mutation.
func (m *UserBaseInfoMutation) UserProfilePhotoURLCleared() bool {
	_, ok := m.clearedFields[userbaseinfo.FieldUserProfilePhotoURL]
	return ok
}

// ResetUserProfilePhotoURL resets all changes to the "user_profile_photo_url" field.
func (m *UserBaseInfoMutation) ResetUserProfilePhotoURL() {
	m.user_profile_photo_url = nil
	delete(m.clearedFields, userbaseinfo.FieldUserProfilePhotoURL)
}

// SetFollowCount sets the "follow_count" field.
func (m *UserBaseInfoMutation) SetFollowCount(i int32) {
	m.follow_count = &i
	m.addfollow_count = nil
}

// FollowCount returns the value of the "follow_count" field in the mutation.
func (m *UserBaseInfoMutation) FollowCount() (r int32, exists bool) {
	v := m.follow_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowCount returns the old "follow_count" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldFollowCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowCount: %w", err)
	}
	return oldValue.FollowCount, nil
}

// AddFollowCount adds i to the "follow_count" field.
func (m *UserBaseInfoMutation) AddFollowCount(i int32) {
	if m.addfollow_count != nil {
		*m.addfollow_count += i
	} else {
		m.addfollow_count = &i
	}
}

// AddedFollowCount returns the value that was added to the "follow_count" field in this mutation.
func (m *UserBaseInfoMutation) AddedFollowCount() (r int32, exists bool) {
	v := m.addfollow_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowCount resets all changes to the "follow_count" field.
func (m *UserBaseInfoMutation) ResetFollowCount() {
	m.follow_count = nil
	m.addfollow_count = nil
}

// SetFanCount sets the "fan_count" field.
func (m *UserBaseInfoMutation) SetFanCount(i int32) {
	m.fan_count = &i
	m.addfan_count = nil
}

// FanCount returns the value of the "fan_count" field in the mutation.
func (m *UserBaseInfoMutation) FanCount() (r int32, exists bool) {
	v := m.fan_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFanCount returns the old "fan_count" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldFanCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFanCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFanCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFanCount: %w", err)
	}
	return oldValue.FanCount, nil
}

// AddFanCount adds i to the "fan_count" field.
func (m *UserBaseInfoMutation) AddFanCount(i int32) {
	if m.addfan_count != nil {
		*m.addfan_count += i
	} else {
		m.addfan_count = &i
	}
}

// AddedFanCount returns the value that was added to the "fan_count" field in this mutation.
func (m *UserBaseInfoMutation) AddedFanCount() (r int32, exists bool) {
	v := m.addfan_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFanCount resets all changes to the "fan_count" field.
func (m *UserBaseInfoMutation) ResetFanCount() {
	m.fan_count = nil
	m.addfan_count = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserBaseInfoMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserBaseInfoMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *UserBaseInfoMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[userbaseinfo.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *UserBaseInfoMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[userbaseinfo.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserBaseInfoMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, userbaseinfo.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *UserBaseInfoMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserBaseInfoMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserBaseInfo entity.
// If the UserBaseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBaseInfoMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *UserBaseInfoMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[userbaseinfo.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *UserBaseInfoMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[userbaseinfo.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserBaseInfoMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, userbaseinfo.FieldUpdateTime)
}

// Where appends a list predicates to the UserBaseInfoMutation builder.
func (m *UserBaseInfoMutation) Where(ps ...predicate.UserBaseInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBaseInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBaseInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBaseInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBaseInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBaseInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBaseInfo).
func (m *UserBaseInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBaseInfoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user_id != nil {
		fields = append(fields, userbaseinfo.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, userbaseinfo.FieldUsername)
	}
	if m.sex != nil {
		fields = append(fields, userbaseinfo.FieldSex)
	}
	if m.birth != nil {
		fields = append(fields, userbaseinfo.FieldBirth)
	}
	if m.area != nil {
		fields = append(fields, userbaseinfo.FieldArea)
	}
	if m.user_profile != nil {
		fields = append(fields, userbaseinfo.FieldUserProfile)
	}
	if m.user_profile_photo_url != nil {
		fields = append(fields, userbaseinfo.FieldUserProfilePhotoURL)
	}
	if m.follow_count != nil {
		fields = append(fields, userbaseinfo.FieldFollowCount)
	}
	if m.fan_count != nil {
		fields = append(fields, userbaseinfo.FieldFanCount)
	}
	if m.create_time != nil {
		fields = append(fields, userbaseinfo.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userbaseinfo.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBaseInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbaseinfo.FieldUserID:
		return m.UserID()
	case userbaseinfo.FieldUsername:
		return m.Username()
	case userbaseinfo.FieldSex:
		return m.Sex()
	case userbaseinfo.FieldBirth:
		return m.Birth()
	case userbaseinfo.FieldArea:
		return m.Area()
	case userbaseinfo.FieldUserProfile:
		return m.UserProfile()
	case userbaseinfo.FieldUserProfilePhotoURL:
		return m.UserProfilePhotoURL()
	case userbaseinfo.FieldFollowCount:
		return m.FollowCount()
	case userbaseinfo.FieldFanCount:
		return m.FanCount()
	case userbaseinfo.FieldCreateTime:
		return m.CreateTime()
	case userbaseinfo.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBaseInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbaseinfo.FieldUserID:
		return m.OldUserID(ctx)
	case userbaseinfo.FieldUsername:
		return m.OldUsername(ctx)
	case userbaseinfo.FieldSex:
		return m.OldSex(ctx)
	case userbaseinfo.FieldBirth:
		return m.OldBirth(ctx)
	case userbaseinfo.FieldArea:
		return m.OldArea(ctx)
	case userbaseinfo.FieldUserProfile:
		return m.OldUserProfile(ctx)
	case userbaseinfo.FieldUserProfilePhotoURL:
		return m.OldUserProfilePhotoURL(ctx)
	case userbaseinfo.FieldFollowCount:
		return m.OldFollowCount(ctx)
	case userbaseinfo.FieldFanCount:
		return m.OldFanCount(ctx)
	case userbaseinfo.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userbaseinfo.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserBaseInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBaseInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbaseinfo.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbaseinfo.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case userbaseinfo.FieldSex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case userbaseinfo.FieldBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirth(v)
		return nil
	case userbaseinfo.FieldArea:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case userbaseinfo.FieldUserProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserProfile(v)
		return nil
	case userbaseinfo.FieldUserProfilePhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserProfilePhotoURL(v)
		return nil
	case userbaseinfo.FieldFollowCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowCount(v)
		return nil
	case userbaseinfo.FieldFanCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFanCount(v)
		return nil
	case userbaseinfo.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userbaseinfo.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserBaseInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBaseInfoMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userbaseinfo.FieldUserID)
	}
	if m.addsex != nil {
		fields = append(fields, userbaseinfo.FieldSex)
	}
	if m.addarea != nil {
		fields = append(fields, userbaseinfo.FieldArea)
	}
	if m.addfollow_count != nil {
		fields = append(fields, userbaseinfo.FieldFollowCount)
	}
	if m.addfan_count != nil {
		fields = append(fields, userbaseinfo.FieldFanCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBaseInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userbaseinfo.FieldUserID:
		return m.AddedUserID()
	case userbaseinfo.FieldSex:
		return m.AddedSex()
	case userbaseinfo.FieldArea:
		return m.AddedArea()
	case userbaseinfo.FieldFollowCount:
		return m.AddedFollowCount()
	case userbaseinfo.FieldFanCount:
		return m.AddedFanCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBaseInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userbaseinfo.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userbaseinfo.FieldSex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSex(v)
		return nil
	case userbaseinfo.FieldArea:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArea(v)
		return nil
	case userbaseinfo.FieldFollowCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowCount(v)
		return nil
	case userbaseinfo.FieldFanCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFanCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserBaseInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBaseInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userbaseinfo.FieldBirth) {
		fields = append(fields, userbaseinfo.FieldBirth)
	}
	if m.FieldCleared(userbaseinfo.FieldUserProfile) {
		fields = append(fields, userbaseinfo.FieldUserProfile)
	}
	if m.FieldCleared(userbaseinfo.FieldUserProfilePhotoURL) {
		fields = append(fields, userbaseinfo.FieldUserProfilePhotoURL)
	}
	if m.FieldCleared(userbaseinfo.FieldCreateTime) {
		fields = append(fields, userbaseinfo.FieldCreateTime)
	}
	if m.FieldCleared(userbaseinfo.FieldUpdateTime) {
		fields = append(fields, userbaseinfo.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBaseInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBaseInfoMutation) ClearField(name string) error {
	switch name {
	case userbaseinfo.FieldBirth:
		m.ClearBirth()
		return nil
	case userbaseinfo.FieldUserProfile:
		m.ClearUserProfile()
		return nil
	case userbaseinfo.FieldUserProfilePhotoURL:
		m.ClearUserProfilePhotoURL()
		return nil
	case userbaseinfo.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case userbaseinfo.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserBaseInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBaseInfoMutation) ResetField(name string) error {
	switch name {
	case userbaseinfo.FieldUserID:
		m.ResetUserID()
		return nil
	case userbaseinfo.FieldUsername:
		m.ResetUsername()
		return nil
	case userbaseinfo.FieldSex:
		m.ResetSex()
		return nil
	case userbaseinfo.FieldBirth:
		m.ResetBirth()
		return nil
	case userbaseinfo.FieldArea:
		m.ResetArea()
		return nil
	case userbaseinfo.FieldUserProfile:
		m.ResetUserProfile()
		return nil
	case userbaseinfo.FieldUserProfilePhotoURL:
		m.ResetUserProfilePhotoURL()
		return nil
	case userbaseinfo.FieldFollowCount:
		m.ResetFollowCount()
		return nil
	case userbaseinfo.FieldFanCount:
		m.ResetFanCount()
		return nil
	case userbaseinfo.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userbaseinfo.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserBaseInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBaseInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBaseInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBaseInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBaseInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBaseInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBaseInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBaseInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserBaseInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBaseInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserBaseInfo edge %s", name)
}

// UserFollowInfoMutation represents an operation that mutates the UserFollowInfo nodes in the graph.
type UserFollowInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uint64
	adduser_id    *int64
	follow_id     *uint64
	addfollow_id  *int64
	status        *int8
	addstatus     *int8
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserFollowInfo, error)
	predicates    []predicate.UserFollowInfo
}

var _ ent.Mutation = (*UserFollowInfoMutation)(nil)

// userfollowinfoOption allows management of the mutation configuration using functional options.
type userfollowinfoOption func(*UserFollowInfoMutation)

// newUserFollowInfoMutation creates new mutation for the UserFollowInfo entity.
func newUserFollowInfoMutation(c config, op Op, opts ...userfollowinfoOption) *UserFollowInfoMutation {
	m := &UserFollowInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowInfoID sets the ID field of the mutation.
func withUserFollowInfoID(id int) userfollowinfoOption {
	return func(m *UserFollowInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowInfo
		)
		m.oldValue = func(ctx context.Context) (*UserFollowInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowInfo sets the old UserFollowInfo of the mutation.
func withUserFollowInfo(node *UserFollowInfo) userfollowinfoOption {
	return func(m *UserFollowInfoMutation) {
		m.oldValue = func(context.Context) (*UserFollowInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFollowInfo entities.
func (m *UserFollowInfoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserFollowInfoMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFollowInfoMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFollowInfo entity.
// If the UserFollowInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowInfoMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserFollowInfoMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserFollowInfoMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFollowInfoMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetFollowID sets the "follow_id" field.
func (m *UserFollowInfoMutation) SetFollowID(u uint64) {
	m.follow_id = &u
	m.addfollow_id = nil
}

// FollowID returns the value of the "follow_id" field in the mutation.
func (m *UserFollowInfoMutation) FollowID() (r uint64, exists bool) {
	v := m.follow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowID returns the old "follow_id" field's value of the UserFollowInfo entity.
// If the UserFollowInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowInfoMutation) OldFollowID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowID: %w", err)
	}
	return oldValue.FollowID, nil
}

// AddFollowID adds u to the "follow_id" field.
func (m *UserFollowInfoMutation) AddFollowID(u int64) {
	if m.addfollow_id != nil {
		*m.addfollow_id += u
	} else {
		m.addfollow_id = &u
	}
}

// AddedFollowID returns the value that was added to the "follow_id" field in this mutation.
func (m *UserFollowInfoMutation) AddedFollowID() (r int64, exists bool) {
	v := m.addfollow_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowID resets all changes to the "follow_id" field.
func (m *UserFollowInfoMutation) ResetFollowID() {
	m.follow_id = nil
	m.addfollow_id = nil
}

// SetStatus sets the "status" field.
func (m *UserFollowInfoMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserFollowInfoMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserFollowInfo entity.
// If the UserFollowInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowInfoMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserFollowInfoMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserFollowInfoMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserFollowInfoMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserFollowInfoMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserFollowInfoMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserFollowInfo entity.
// If the UserFollowInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowInfoMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *UserFollowInfoMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[userfollowinfo.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *UserFollowInfoMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[userfollowinfo.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserFollowInfoMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, userfollowinfo.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *UserFollowInfoMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserFollowInfoMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserFollowInfo entity.
// If the UserFollowInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowInfoMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *UserFollowInfoMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[userfollowinfo.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *UserFollowInfoMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[userfollowinfo.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserFollowInfoMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, userfollowinfo.FieldUpdateTime)
}

// Where appends a list predicates to the UserFollowInfoMutation builder.
func (m *UserFollowInfoMutation) Where(ps ...predicate.UserFollowInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowInfo).
func (m *UserFollowInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowInfoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, userfollowinfo.FieldUserID)
	}
	if m.follow_id != nil {
		fields = append(fields, userfollowinfo.FieldFollowID)
	}
	if m.status != nil {
		fields = append(fields, userfollowinfo.FieldStatus)
	}
	if m.create_time != nil {
		fields = append(fields, userfollowinfo.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userfollowinfo.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfollowinfo.FieldUserID:
		return m.UserID()
	case userfollowinfo.FieldFollowID:
		return m.FollowID()
	case userfollowinfo.FieldStatus:
		return m.Status()
	case userfollowinfo.FieldCreateTime:
		return m.CreateTime()
	case userfollowinfo.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfollowinfo.FieldUserID:
		return m.OldUserID(ctx)
	case userfollowinfo.FieldFollowID:
		return m.OldFollowID(ctx)
	case userfollowinfo.FieldStatus:
		return m.OldStatus(ctx)
	case userfollowinfo.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userfollowinfo.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserFollowInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfollowinfo.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfollowinfo.FieldFollowID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowID(v)
		return nil
	case userfollowinfo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userfollowinfo.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userfollowinfo.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowInfoMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userfollowinfo.FieldUserID)
	}
	if m.addfollow_id != nil {
		fields = append(fields, userfollowinfo.FieldFollowID)
	}
	if m.addstatus != nil {
		fields = append(fields, userfollowinfo.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfollowinfo.FieldUserID:
		return m.AddedUserID()
	case userfollowinfo.FieldFollowID:
		return m.AddedFollowID()
	case userfollowinfo.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfollowinfo.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userfollowinfo.FieldFollowID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowID(v)
		return nil
	case userfollowinfo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userfollowinfo.FieldCreateTime) {
		fields = append(fields, userfollowinfo.FieldCreateTime)
	}
	if m.FieldCleared(userfollowinfo.FieldUpdateTime) {
		fields = append(fields, userfollowinfo.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowInfoMutation) ClearField(name string) error {
	switch name {
	case userfollowinfo.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case userfollowinfo.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserFollowInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowInfoMutation) ResetField(name string) error {
	switch name {
	case userfollowinfo.FieldUserID:
		m.ResetUserID()
		return nil
	case userfollowinfo.FieldFollowID:
		m.ResetFollowID()
		return nil
	case userfollowinfo.FieldStatus:
		m.ResetStatus()
		return nil
	case userfollowinfo.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userfollowinfo.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserFollowInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserFollowInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserFollowInfo edge %s", name)
}

// UserPasswordMutation represents an operation that mutates the UserPassword nodes in the graph.
type UserPasswordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uint64
	adduser_id    *int64
	salt          *string
	pwd           *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserPassword, error)
	predicates    []predicate.UserPassword
}

var _ ent.Mutation = (*UserPasswordMutation)(nil)

// userpasswordOption allows management of the mutation configuration using functional options.
type userpasswordOption func(*UserPasswordMutation)

// newUserPasswordMutation creates new mutation for the UserPassword entity.
func newUserPasswordMutation(c config, op Op, opts ...userpasswordOption) *UserPasswordMutation {
	m := &UserPasswordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPasswordID sets the ID field of the mutation.
func withUserPasswordID(id int) userpasswordOption {
	return func(m *UserPasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPassword
		)
		m.oldValue = func(ctx context.Context) (*UserPassword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPassword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPassword sets the old UserPassword of the mutation.
func withUserPassword(node *UserPassword) userpasswordOption {
	return func(m *UserPasswordMutation) {
		m.oldValue = func(context.Context) (*UserPassword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPassword entities.
func (m *UserPasswordMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPasswordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPasswordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPassword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserPasswordMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPasswordMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserPasswordMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserPasswordMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserPasswordMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[userpassword.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserPasswordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPasswordMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, userpassword.FieldUserID)
}

// SetSalt sets the "salt" field.
func (m *UserPasswordMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserPasswordMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserPasswordMutation) ResetSalt() {
	m.salt = nil
}

// SetPwd sets the "pwd" field.
func (m *UserPasswordMutation) SetPwd(s string) {
	m.pwd = &s
}

// Pwd returns the value of the "pwd" field in the mutation.
func (m *UserPasswordMutation) Pwd() (r string, exists bool) {
	v := m.pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPwd returns the old "pwd" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPwd: %w", err)
	}
	return oldValue.Pwd, nil
}

// ResetPwd resets all changes to the "pwd" field.
func (m *UserPasswordMutation) ResetPwd() {
	m.pwd = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserPasswordMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserPasswordMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *UserPasswordMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[userpassword.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *UserPasswordMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserPasswordMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, userpassword.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *UserPasswordMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserPasswordMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *UserPasswordMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[userpassword.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserPasswordMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, userpassword.FieldUpdateTime)
}

// Where appends a list predicates to the UserPasswordMutation builder.
func (m *UserPasswordMutation) Where(ps ...predicate.UserPassword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPassword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPassword).
func (m *UserPasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPasswordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.salt != nil {
		fields = append(fields, userpassword.FieldSalt)
	}
	if m.pwd != nil {
		fields = append(fields, userpassword.FieldPwd)
	}
	if m.create_time != nil {
		fields = append(fields, userpassword.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userpassword.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldUserID:
		return m.UserID()
	case userpassword.FieldSalt:
		return m.Salt()
	case userpassword.FieldPwd:
		return m.Pwd()
	case userpassword.FieldCreateTime:
		return m.CreateTime()
	case userpassword.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpassword.FieldUserID:
		return m.OldUserID(ctx)
	case userpassword.FieldSalt:
		return m.OldSalt(ctx)
	case userpassword.FieldPwd:
		return m.OldPwd(ctx)
	case userpassword.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userpassword.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserPassword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpassword.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case userpassword.FieldPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPwd(v)
		return nil
	case userpassword.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userpassword.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPasswordMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userpassword.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPasswordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpassword.FieldUserID) {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.FieldCleared(userpassword.FieldCreateTime) {
		fields = append(fields, userpassword.FieldCreateTime)
	}
	if m.FieldCleared(userpassword.FieldUpdateTime) {
		fields = append(fields, userpassword.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPasswordMutation) ClearField(name string) error {
	switch name {
	case userpassword.FieldUserID:
		m.ClearUserID()
		return nil
	case userpassword.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case userpassword.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserPassword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPasswordMutation) ResetField(name string) error {
	switch name {
	case userpassword.FieldUserID:
		m.ResetUserID()
		return nil
	case userpassword.FieldSalt:
		m.ResetSalt()
		return nil
	case userpassword.FieldPwd:
		m.ResetPwd()
		return nil
	case userpassword.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userpassword.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPasswordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPasswordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPasswordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserPassword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPasswordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserPassword edge %s", name)
}

// VideoCollectionMutation represents an operation that mutates the VideoCollection nodes in the graph.
type VideoCollectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	video_id      *int
	addvideo_id   *int
	status        *int8
	addstatus     *int8
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VideoCollection, error)
	predicates    []predicate.VideoCollection
}

var _ ent.Mutation = (*VideoCollectionMutation)(nil)

// videocollectionOption allows management of the mutation configuration using functional options.
type videocollectionOption func(*VideoCollectionMutation)

// newVideoCollectionMutation creates new mutation for the VideoCollection entity.
func newVideoCollectionMutation(c config, op Op, opts ...videocollectionOption) *VideoCollectionMutation {
	m := &VideoCollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoCollectionID sets the ID field of the mutation.
func withVideoCollectionID(id int) videocollectionOption {
	return func(m *VideoCollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoCollection
		)
		m.oldValue = func(ctx context.Context) (*VideoCollection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoCollection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoCollection sets the old VideoCollection of the mutation.
func withVideoCollection(node *VideoCollection) videocollectionOption {
	return func(m *VideoCollectionMutation) {
		m.oldValue = func(context.Context) (*VideoCollection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoCollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoCollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VideoCollection entities.
func (m *VideoCollectionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoCollectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoCollectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VideoCollection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *VideoCollectionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VideoCollectionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VideoCollection entity.
// If the VideoCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCollectionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *VideoCollectionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *VideoCollectionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VideoCollectionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetVideoID sets the "video_id" field.
func (m *VideoCollectionMutation) SetVideoID(i int) {
	m.video_id = &i
	m.addvideo_id = nil
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *VideoCollectionMutation) VideoID() (r int, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the VideoCollection entity.
// If the VideoCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCollectionMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// AddVideoID adds i to the "video_id" field.
func (m *VideoCollectionMutation) AddVideoID(i int) {
	if m.addvideo_id != nil {
		*m.addvideo_id += i
	} else {
		m.addvideo_id = &i
	}
}

// AddedVideoID returns the value that was added to the "video_id" field in this mutation.
func (m *VideoCollectionMutation) AddedVideoID() (r int, exists bool) {
	v := m.addvideo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *VideoCollectionMutation) ResetVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
}

// SetStatus sets the "status" field.
func (m *VideoCollectionMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VideoCollectionMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VideoCollection entity.
// If the VideoCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCollectionMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VideoCollectionMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VideoCollectionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *VideoCollectionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateTime sets the "create_time" field.
func (m *VideoCollectionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VideoCollectionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the VideoCollection entity.
// If the VideoCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCollectionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *VideoCollectionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[videocollection.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *VideoCollectionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[videocollection.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VideoCollectionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, videocollection.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *VideoCollectionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VideoCollectionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the VideoCollection entity.
// If the VideoCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCollectionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *VideoCollectionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[videocollection.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *VideoCollectionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[videocollection.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VideoCollectionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, videocollection.FieldUpdateTime)
}

// Where appends a list predicates to the VideoCollectionMutation builder.
func (m *VideoCollectionMutation) Where(ps ...predicate.VideoCollection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoCollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoCollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VideoCollection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoCollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoCollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VideoCollection).
func (m *VideoCollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoCollectionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, videocollection.FieldUserID)
	}
	if m.video_id != nil {
		fields = append(fields, videocollection.FieldVideoID)
	}
	if m.status != nil {
		fields = append(fields, videocollection.FieldStatus)
	}
	if m.create_time != nil {
		fields = append(fields, videocollection.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, videocollection.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoCollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videocollection.FieldUserID:
		return m.UserID()
	case videocollection.FieldVideoID:
		return m.VideoID()
	case videocollection.FieldStatus:
		return m.Status()
	case videocollection.FieldCreateTime:
		return m.CreateTime()
	case videocollection.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoCollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videocollection.FieldUserID:
		return m.OldUserID(ctx)
	case videocollection.FieldVideoID:
		return m.OldVideoID(ctx)
	case videocollection.FieldStatus:
		return m.OldStatus(ctx)
	case videocollection.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case videocollection.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown VideoCollection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoCollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videocollection.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case videocollection.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case videocollection.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case videocollection.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case videocollection.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown VideoCollection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoCollectionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, videocollection.FieldUserID)
	}
	if m.addvideo_id != nil {
		fields = append(fields, videocollection.FieldVideoID)
	}
	if m.addstatus != nil {
		fields = append(fields, videocollection.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoCollectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videocollection.FieldUserID:
		return m.AddedUserID()
	case videocollection.FieldVideoID:
		return m.AddedVideoID()
	case videocollection.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoCollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videocollection.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case videocollection.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoID(v)
		return nil
	case videocollection.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown VideoCollection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoCollectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videocollection.FieldCreateTime) {
		fields = append(fields, videocollection.FieldCreateTime)
	}
	if m.FieldCleared(videocollection.FieldUpdateTime) {
		fields = append(fields, videocollection.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoCollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoCollectionMutation) ClearField(name string) error {
	switch name {
	case videocollection.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case videocollection.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoCollection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoCollectionMutation) ResetField(name string) error {
	switch name {
	case videocollection.FieldUserID:
		m.ResetUserID()
		return nil
	case videocollection.FieldVideoID:
		m.ResetVideoID()
		return nil
	case videocollection.FieldStatus:
		m.ResetStatus()
		return nil
	case videocollection.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case videocollection.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoCollection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoCollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoCollectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoCollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoCollectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoCollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoCollectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoCollectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VideoCollection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoCollectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VideoCollection edge %s", name)
}

// VideoCommentMutation represents an operation that mutates the VideoComment nodes in the graph.
type VideoCommentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	comment_id     *int
	addcomment_id  *int
	pcomment_id    *int
	addpcomment_id *int
	video_id       *int
	addvideo_id    *int
	user_id        *int
	adduser_id     *int
	comment_text   *string
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*VideoComment, error)
	predicates     []predicate.VideoComment
}

var _ ent.Mutation = (*VideoCommentMutation)(nil)

// videocommentOption allows management of the mutation configuration using functional options.
type videocommentOption func(*VideoCommentMutation)

// newVideoCommentMutation creates new mutation for the VideoComment entity.
func newVideoCommentMutation(c config, op Op, opts ...videocommentOption) *VideoCommentMutation {
	m := &VideoCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoCommentID sets the ID field of the mutation.
func withVideoCommentID(id int) videocommentOption {
	return func(m *VideoCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoComment
		)
		m.oldValue = func(ctx context.Context) (*VideoComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoComment sets the old VideoComment of the mutation.
func withVideoComment(node *VideoComment) videocommentOption {
	return func(m *VideoCommentMutation) {
		m.oldValue = func(context.Context) (*VideoComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VideoComment entities.
func (m *VideoCommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VideoComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommentID sets the "comment_id" field.
func (m *VideoCommentMutation) SetCommentID(i int) {
	m.comment_id = &i
	m.addcomment_id = nil
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *VideoCommentMutation) CommentID() (r int, exists bool) {
	v := m.comment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldCommentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// AddCommentID adds i to the "comment_id" field.
func (m *VideoCommentMutation) AddCommentID(i int) {
	if m.addcomment_id != nil {
		*m.addcomment_id += i
	} else {
		m.addcomment_id = &i
	}
}

// AddedCommentID returns the value that was added to the "comment_id" field in this mutation.
func (m *VideoCommentMutation) AddedCommentID() (r int, exists bool) {
	v := m.addcomment_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *VideoCommentMutation) ResetCommentID() {
	m.comment_id = nil
	m.addcomment_id = nil
}

// SetPcommentID sets the "pcomment_id" field.
func (m *VideoCommentMutation) SetPcommentID(i int) {
	m.pcomment_id = &i
	m.addpcomment_id = nil
}

// PcommentID returns the value of the "pcomment_id" field in the mutation.
func (m *VideoCommentMutation) PcommentID() (r int, exists bool) {
	v := m.pcomment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPcommentID returns the old "pcomment_id" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldPcommentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPcommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPcommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPcommentID: %w", err)
	}
	return oldValue.PcommentID, nil
}

// AddPcommentID adds i to the "pcomment_id" field.
func (m *VideoCommentMutation) AddPcommentID(i int) {
	if m.addpcomment_id != nil {
		*m.addpcomment_id += i
	} else {
		m.addpcomment_id = &i
	}
}

// AddedPcommentID returns the value that was added to the "pcomment_id" field in this mutation.
func (m *VideoCommentMutation) AddedPcommentID() (r int, exists bool) {
	v := m.addpcomment_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPcommentID resets all changes to the "pcomment_id" field.
func (m *VideoCommentMutation) ResetPcommentID() {
	m.pcomment_id = nil
	m.addpcomment_id = nil
}

// SetVideoID sets the "video_id" field.
func (m *VideoCommentMutation) SetVideoID(i int) {
	m.video_id = &i
	m.addvideo_id = nil
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *VideoCommentMutation) VideoID() (r int, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// AddVideoID adds i to the "video_id" field.
func (m *VideoCommentMutation) AddVideoID(i int) {
	if m.addvideo_id != nil {
		*m.addvideo_id += i
	} else {
		m.addvideo_id = &i
	}
}

// AddedVideoID returns the value that was added to the "video_id" field in this mutation.
func (m *VideoCommentMutation) AddedVideoID() (r int, exists bool) {
	v := m.addvideo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *VideoCommentMutation) ResetVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
}

// SetUserID sets the "user_id" field.
func (m *VideoCommentMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VideoCommentMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *VideoCommentMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *VideoCommentMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VideoCommentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCommentText sets the "comment_text" field.
func (m *VideoCommentMutation) SetCommentText(s string) {
	m.comment_text = &s
}

// CommentText returns the value of the "comment_text" field in the mutation.
func (m *VideoCommentMutation) CommentText() (r string, exists bool) {
	v := m.comment_text
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentText returns the old "comment_text" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldCommentText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentText: %w", err)
	}
	return oldValue.CommentText, nil
}

// ClearCommentText clears the value of the "comment_text" field.
func (m *VideoCommentMutation) ClearCommentText() {
	m.comment_text = nil
	m.clearedFields[videocomment.FieldCommentText] = struct{}{}
}

// CommentTextCleared returns if the "comment_text" field was cleared in this mutation.
func (m *VideoCommentMutation) CommentTextCleared() bool {
	_, ok := m.clearedFields[videocomment.FieldCommentText]
	return ok
}

// ResetCommentText resets all changes to the "comment_text" field.
func (m *VideoCommentMutation) ResetCommentText() {
	m.comment_text = nil
	delete(m.clearedFields, videocomment.FieldCommentText)
}

// SetCreateTime sets the "create_time" field.
func (m *VideoCommentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VideoCommentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *VideoCommentMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[videocomment.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *VideoCommentMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[videocomment.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VideoCommentMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, videocomment.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *VideoCommentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VideoCommentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the VideoComment entity.
// If the VideoComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCommentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *VideoCommentMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[videocomment.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *VideoCommentMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[videocomment.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VideoCommentMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, videocomment.FieldUpdateTime)
}

// Where appends a list predicates to the VideoCommentMutation builder.
func (m *VideoCommentMutation) Where(ps ...predicate.VideoComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VideoComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VideoComment).
func (m *VideoCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoCommentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.comment_id != nil {
		fields = append(fields, videocomment.FieldCommentID)
	}
	if m.pcomment_id != nil {
		fields = append(fields, videocomment.FieldPcommentID)
	}
	if m.video_id != nil {
		fields = append(fields, videocomment.FieldVideoID)
	}
	if m.user_id != nil {
		fields = append(fields, videocomment.FieldUserID)
	}
	if m.comment_text != nil {
		fields = append(fields, videocomment.FieldCommentText)
	}
	if m.create_time != nil {
		fields = append(fields, videocomment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, videocomment.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videocomment.FieldCommentID:
		return m.CommentID()
	case videocomment.FieldPcommentID:
		return m.PcommentID()
	case videocomment.FieldVideoID:
		return m.VideoID()
	case videocomment.FieldUserID:
		return m.UserID()
	case videocomment.FieldCommentText:
		return m.CommentText()
	case videocomment.FieldCreateTime:
		return m.CreateTime()
	case videocomment.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videocomment.FieldCommentID:
		return m.OldCommentID(ctx)
	case videocomment.FieldPcommentID:
		return m.OldPcommentID(ctx)
	case videocomment.FieldVideoID:
		return m.OldVideoID(ctx)
	case videocomment.FieldUserID:
		return m.OldUserID(ctx)
	case videocomment.FieldCommentText:
		return m.OldCommentText(ctx)
	case videocomment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case videocomment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown VideoComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videocomment.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case videocomment.FieldPcommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPcommentID(v)
		return nil
	case videocomment.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case videocomment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case videocomment.FieldCommentText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentText(v)
		return nil
	case videocomment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case videocomment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown VideoComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoCommentMutation) AddedFields() []string {
	var fields []string
	if m.addcomment_id != nil {
		fields = append(fields, videocomment.FieldCommentID)
	}
	if m.addpcomment_id != nil {
		fields = append(fields, videocomment.FieldPcommentID)
	}
	if m.addvideo_id != nil {
		fields = append(fields, videocomment.FieldVideoID)
	}
	if m.adduser_id != nil {
		fields = append(fields, videocomment.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videocomment.FieldCommentID:
		return m.AddedCommentID()
	case videocomment.FieldPcommentID:
		return m.AddedPcommentID()
	case videocomment.FieldVideoID:
		return m.AddedVideoID()
	case videocomment.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videocomment.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentID(v)
		return nil
	case videocomment.FieldPcommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPcommentID(v)
		return nil
	case videocomment.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoID(v)
		return nil
	case videocomment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VideoComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videocomment.FieldCommentText) {
		fields = append(fields, videocomment.FieldCommentText)
	}
	if m.FieldCleared(videocomment.FieldCreateTime) {
		fields = append(fields, videocomment.FieldCreateTime)
	}
	if m.FieldCleared(videocomment.FieldUpdateTime) {
		fields = append(fields, videocomment.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoCommentMutation) ClearField(name string) error {
	switch name {
	case videocomment.FieldCommentText:
		m.ClearCommentText()
		return nil
	case videocomment.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case videocomment.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoCommentMutation) ResetField(name string) error {
	switch name {
	case videocomment.FieldCommentID:
		m.ResetCommentID()
		return nil
	case videocomment.FieldPcommentID:
		m.ResetPcommentID()
		return nil
	case videocomment.FieldVideoID:
		m.ResetVideoID()
		return nil
	case videocomment.FieldUserID:
		m.ResetUserID()
		return nil
	case videocomment.FieldCommentText:
		m.ResetCommentText()
		return nil
	case videocomment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case videocomment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoCommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoCommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoCommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VideoComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoCommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VideoComment edge %s", name)
}

// VideoLikeMutation represents an operation that mutates the VideoLike nodes in the graph.
type VideoLikeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	video_id      *int
	addvideo_id   *int
	status        *int8
	addstatus     *int8
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VideoLike, error)
	predicates    []predicate.VideoLike
}

var _ ent.Mutation = (*VideoLikeMutation)(nil)

// videolikeOption allows management of the mutation configuration using functional options.
type videolikeOption func(*VideoLikeMutation)

// newVideoLikeMutation creates new mutation for the VideoLike entity.
func newVideoLikeMutation(c config, op Op, opts ...videolikeOption) *VideoLikeMutation {
	m := &VideoLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoLikeID sets the ID field of the mutation.
func withVideoLikeID(id int) videolikeOption {
	return func(m *VideoLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoLike
		)
		m.oldValue = func(ctx context.Context) (*VideoLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoLike sets the old VideoLike of the mutation.
func withVideoLike(node *VideoLike) videolikeOption {
	return func(m *VideoLikeMutation) {
		m.oldValue = func(context.Context) (*VideoLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VideoLike entities.
func (m *VideoLikeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoLikeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoLikeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VideoLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *VideoLikeMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VideoLikeMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VideoLike entity.
// If the VideoLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoLikeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *VideoLikeMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *VideoLikeMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VideoLikeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetVideoID sets the "video_id" field.
func (m *VideoLikeMutation) SetVideoID(i int) {
	m.video_id = &i
	m.addvideo_id = nil
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *VideoLikeMutation) VideoID() (r int, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the VideoLike entity.
// If the VideoLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoLikeMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// AddVideoID adds i to the "video_id" field.
func (m *VideoLikeMutation) AddVideoID(i int) {
	if m.addvideo_id != nil {
		*m.addvideo_id += i
	} else {
		m.addvideo_id = &i
	}
}

// AddedVideoID returns the value that was added to the "video_id" field in this mutation.
func (m *VideoLikeMutation) AddedVideoID() (r int, exists bool) {
	v := m.addvideo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *VideoLikeMutation) ResetVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
}

// SetStatus sets the "status" field.
func (m *VideoLikeMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VideoLikeMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VideoLike entity.
// If the VideoLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoLikeMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VideoLikeMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VideoLikeMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *VideoLikeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateTime sets the "create_time" field.
func (m *VideoLikeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VideoLikeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the VideoLike entity.
// If the VideoLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoLikeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *VideoLikeMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[videolike.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *VideoLikeMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[videolike.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VideoLikeMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, videolike.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *VideoLikeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VideoLikeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the VideoLike entity.
// If the VideoLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoLikeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *VideoLikeMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[videolike.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *VideoLikeMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[videolike.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VideoLikeMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, videolike.FieldUpdateTime)
}

// Where appends a list predicates to the VideoLikeMutation builder.
func (m *VideoLikeMutation) Where(ps ...predicate.VideoLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VideoLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VideoLike).
func (m *VideoLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoLikeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, videolike.FieldUserID)
	}
	if m.video_id != nil {
		fields = append(fields, videolike.FieldVideoID)
	}
	if m.status != nil {
		fields = append(fields, videolike.FieldStatus)
	}
	if m.create_time != nil {
		fields = append(fields, videolike.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, videolike.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videolike.FieldUserID:
		return m.UserID()
	case videolike.FieldVideoID:
		return m.VideoID()
	case videolike.FieldStatus:
		return m.Status()
	case videolike.FieldCreateTime:
		return m.CreateTime()
	case videolike.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videolike.FieldUserID:
		return m.OldUserID(ctx)
	case videolike.FieldVideoID:
		return m.OldVideoID(ctx)
	case videolike.FieldStatus:
		return m.OldStatus(ctx)
	case videolike.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case videolike.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown VideoLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videolike.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case videolike.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case videolike.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case videolike.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case videolike.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown VideoLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoLikeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, videolike.FieldUserID)
	}
	if m.addvideo_id != nil {
		fields = append(fields, videolike.FieldVideoID)
	}
	if m.addstatus != nil {
		fields = append(fields, videolike.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videolike.FieldUserID:
		return m.AddedUserID()
	case videolike.FieldVideoID:
		return m.AddedVideoID()
	case videolike.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videolike.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case videolike.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoID(v)
		return nil
	case videolike.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown VideoLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoLikeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videolike.FieldCreateTime) {
		fields = append(fields, videolike.FieldCreateTime)
	}
	if m.FieldCleared(videolike.FieldUpdateTime) {
		fields = append(fields, videolike.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoLikeMutation) ClearField(name string) error {
	switch name {
	case videolike.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case videolike.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoLikeMutation) ResetField(name string) error {
	switch name {
	case videolike.FieldUserID:
		m.ResetUserID()
		return nil
	case videolike.FieldVideoID:
		m.ResetVideoID()
		return nil
	case videolike.FieldStatus:
		m.ResetStatus()
		return nil
	case videolike.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case videolike.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoLikeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoLikeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoLikeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VideoLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoLikeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VideoLike edge %s", name)
}

// VideoMetadatumMutation represents an operation that mutates the VideoMetadatum nodes in the graph.
type VideoMetadatumMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	video_id           *int
	addvideo_id        *int
	user_id            *int
	adduser_id         *int
	cover_url          *string
	video_url          *string
	video_intro        *string
	video_type         *int
	addvideo_type      *int
	publish_address    *int32
	addpublish_address *int32
	create_time        *time.Time
	update_time        *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*VideoMetadatum, error)
	predicates         []predicate.VideoMetadatum
}

var _ ent.Mutation = (*VideoMetadatumMutation)(nil)

// videometadatumOption allows management of the mutation configuration using functional options.
type videometadatumOption func(*VideoMetadatumMutation)

// newVideoMetadatumMutation creates new mutation for the VideoMetadatum entity.
func newVideoMetadatumMutation(c config, op Op, opts ...videometadatumOption) *VideoMetadatumMutation {
	m := &VideoMetadatumMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoMetadatum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoMetadatumID sets the ID field of the mutation.
func withVideoMetadatumID(id int) videometadatumOption {
	return func(m *VideoMetadatumMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoMetadatum
		)
		m.oldValue = func(ctx context.Context) (*VideoMetadatum, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoMetadatum.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoMetadatum sets the old VideoMetadatum of the mutation.
func withVideoMetadatum(node *VideoMetadatum) videometadatumOption {
	return func(m *VideoMetadatumMutation) {
		m.oldValue = func(context.Context) (*VideoMetadatum, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMetadatumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMetadatumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VideoMetadatum entities.
func (m *VideoMetadatumMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMetadatumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMetadatumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VideoMetadatum.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoID sets the "video_id" field.
func (m *VideoMetadatumMutation) SetVideoID(i int) {
	m.video_id = &i
	m.addvideo_id = nil
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *VideoMetadatumMutation) VideoID() (r int, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// AddVideoID adds i to the "video_id" field.
func (m *VideoMetadatumMutation) AddVideoID(i int) {
	if m.addvideo_id != nil {
		*m.addvideo_id += i
	} else {
		m.addvideo_id = &i
	}
}

// AddedVideoID returns the value that was added to the "video_id" field in this mutation.
func (m *VideoMetadatumMutation) AddedVideoID() (r int, exists bool) {
	v := m.addvideo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *VideoMetadatumMutation) ResetVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
}

// SetUserID sets the "user_id" field.
func (m *VideoMetadatumMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VideoMetadatumMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *VideoMetadatumMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *VideoMetadatumMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VideoMetadatumMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCoverURL sets the "cover_url" field.
func (m *VideoMetadatumMutation) SetCoverURL(s string) {
	m.cover_url = &s
}

// CoverURL returns the value of the "cover_url" field in the mutation.
func (m *VideoMetadatumMutation) CoverURL() (r string, exists bool) {
	v := m.cover_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverURL returns the old "cover_url" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldCoverURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverURL: %w", err)
	}
	return oldValue.CoverURL, nil
}

// ResetCoverURL resets all changes to the "cover_url" field.
func (m *VideoMetadatumMutation) ResetCoverURL() {
	m.cover_url = nil
}

// SetVideoURL sets the "video_url" field.
func (m *VideoMetadatumMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *VideoMetadatumMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *VideoMetadatumMutation) ResetVideoURL() {
	m.video_url = nil
}

// SetVideoIntro sets the "video_intro" field.
func (m *VideoMetadatumMutation) SetVideoIntro(s string) {
	m.video_intro = &s
}

// VideoIntro returns the value of the "video_intro" field in the mutation.
func (m *VideoMetadatumMutation) VideoIntro() (r string, exists bool) {
	v := m.video_intro
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoIntro returns the old "video_intro" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldVideoIntro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoIntro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoIntro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoIntro: %w", err)
	}
	return oldValue.VideoIntro, nil
}

// ClearVideoIntro clears the value of the "video_intro" field.
func (m *VideoMetadatumMutation) ClearVideoIntro() {
	m.video_intro = nil
	m.clearedFields[videometadatum.FieldVideoIntro] = struct{}{}
}

// VideoIntroCleared returns if the "video_intro" field was cleared in this mutation.
func (m *VideoMetadatumMutation) VideoIntroCleared() bool {
	_, ok := m.clearedFields[videometadatum.FieldVideoIntro]
	return ok
}

// ResetVideoIntro resets all changes to the "video_intro" field.
func (m *VideoMetadatumMutation) ResetVideoIntro() {
	m.video_intro = nil
	delete(m.clearedFields, videometadatum.FieldVideoIntro)
}

// SetVideoType sets the "video_type" field.
func (m *VideoMetadatumMutation) SetVideoType(i int) {
	m.video_type = &i
	m.addvideo_type = nil
}

// VideoType returns the value of the "video_type" field in the mutation.
func (m *VideoMetadatumMutation) VideoType() (r int, exists bool) {
	v := m.video_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoType returns the old "video_type" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldVideoType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoType: %w", err)
	}
	return oldValue.VideoType, nil
}

// AddVideoType adds i to the "video_type" field.
func (m *VideoMetadatumMutation) AddVideoType(i int) {
	if m.addvideo_type != nil {
		*m.addvideo_type += i
	} else {
		m.addvideo_type = &i
	}
}

// AddedVideoType returns the value that was added to the "video_type" field in this mutation.
func (m *VideoMetadatumMutation) AddedVideoType() (r int, exists bool) {
	v := m.addvideo_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoType resets all changes to the "video_type" field.
func (m *VideoMetadatumMutation) ResetVideoType() {
	m.video_type = nil
	m.addvideo_type = nil
}

// SetPublishAddress sets the "publish_address" field.
func (m *VideoMetadatumMutation) SetPublishAddress(i int32) {
	m.publish_address = &i
	m.addpublish_address = nil
}

// PublishAddress returns the value of the "publish_address" field in the mutation.
func (m *VideoMetadatumMutation) PublishAddress() (r int32, exists bool) {
	v := m.publish_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishAddress returns the old "publish_address" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldPublishAddress(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishAddress: %w", err)
	}
	return oldValue.PublishAddress, nil
}

// AddPublishAddress adds i to the "publish_address" field.
func (m *VideoMetadatumMutation) AddPublishAddress(i int32) {
	if m.addpublish_address != nil {
		*m.addpublish_address += i
	} else {
		m.addpublish_address = &i
	}
}

// AddedPublishAddress returns the value that was added to the "publish_address" field in this mutation.
func (m *VideoMetadatumMutation) AddedPublishAddress() (r int32, exists bool) {
	v := m.addpublish_address
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublishAddress resets all changes to the "publish_address" field.
func (m *VideoMetadatumMutation) ResetPublishAddress() {
	m.publish_address = nil
	m.addpublish_address = nil
}

// SetCreateTime sets the "create_time" field.
func (m *VideoMetadatumMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VideoMetadatumMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *VideoMetadatumMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[videometadatum.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *VideoMetadatumMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[videometadatum.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VideoMetadatumMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, videometadatum.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *VideoMetadatumMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VideoMetadatumMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the VideoMetadatum entity.
// If the VideoMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMetadatumMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *VideoMetadatumMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[videometadatum.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *VideoMetadatumMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[videometadatum.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VideoMetadatumMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, videometadatum.FieldUpdateTime)
}

// Where appends a list predicates to the VideoMetadatumMutation builder.
func (m *VideoMetadatumMutation) Where(ps ...predicate.VideoMetadatum) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMetadatumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMetadatumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VideoMetadatum, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMetadatumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMetadatumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VideoMetadatum).
func (m *VideoMetadatumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMetadatumMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.video_id != nil {
		fields = append(fields, videometadatum.FieldVideoID)
	}
	if m.user_id != nil {
		fields = append(fields, videometadatum.FieldUserID)
	}
	if m.cover_url != nil {
		fields = append(fields, videometadatum.FieldCoverURL)
	}
	if m.video_url != nil {
		fields = append(fields, videometadatum.FieldVideoURL)
	}
	if m.video_intro != nil {
		fields = append(fields, videometadatum.FieldVideoIntro)
	}
	if m.video_type != nil {
		fields = append(fields, videometadatum.FieldVideoType)
	}
	if m.publish_address != nil {
		fields = append(fields, videometadatum.FieldPublishAddress)
	}
	if m.create_time != nil {
		fields = append(fields, videometadatum.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, videometadatum.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMetadatumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videometadatum.FieldVideoID:
		return m.VideoID()
	case videometadatum.FieldUserID:
		return m.UserID()
	case videometadatum.FieldCoverURL:
		return m.CoverURL()
	case videometadatum.FieldVideoURL:
		return m.VideoURL()
	case videometadatum.FieldVideoIntro:
		return m.VideoIntro()
	case videometadatum.FieldVideoType:
		return m.VideoType()
	case videometadatum.FieldPublishAddress:
		return m.PublishAddress()
	case videometadatum.FieldCreateTime:
		return m.CreateTime()
	case videometadatum.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMetadatumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videometadatum.FieldVideoID:
		return m.OldVideoID(ctx)
	case videometadatum.FieldUserID:
		return m.OldUserID(ctx)
	case videometadatum.FieldCoverURL:
		return m.OldCoverURL(ctx)
	case videometadatum.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case videometadatum.FieldVideoIntro:
		return m.OldVideoIntro(ctx)
	case videometadatum.FieldVideoType:
		return m.OldVideoType(ctx)
	case videometadatum.FieldPublishAddress:
		return m.OldPublishAddress(ctx)
	case videometadatum.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case videometadatum.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown VideoMetadatum field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMetadatumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videometadatum.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case videometadatum.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case videometadatum.FieldCoverURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverURL(v)
		return nil
	case videometadatum.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case videometadatum.FieldVideoIntro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoIntro(v)
		return nil
	case videometadatum.FieldVideoType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoType(v)
		return nil
	case videometadatum.FieldPublishAddress:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishAddress(v)
		return nil
	case videometadatum.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case videometadatum.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown VideoMetadatum field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMetadatumMutation) AddedFields() []string {
	var fields []string
	if m.addvideo_id != nil {
		fields = append(fields, videometadatum.FieldVideoID)
	}
	if m.adduser_id != nil {
		fields = append(fields, videometadatum.FieldUserID)
	}
	if m.addvideo_type != nil {
		fields = append(fields, videometadatum.FieldVideoType)
	}
	if m.addpublish_address != nil {
		fields = append(fields, videometadatum.FieldPublishAddress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMetadatumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videometadatum.FieldVideoID:
		return m.AddedVideoID()
	case videometadatum.FieldUserID:
		return m.AddedUserID()
	case videometadatum.FieldVideoType:
		return m.AddedVideoType()
	case videometadatum.FieldPublishAddress:
		return m.AddedPublishAddress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMetadatumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videometadatum.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoID(v)
		return nil
	case videometadatum.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case videometadatum.FieldVideoType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoType(v)
		return nil
	case videometadatum.FieldPublishAddress:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublishAddress(v)
		return nil
	}
	return fmt.Errorf("unknown VideoMetadatum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMetadatumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videometadatum.FieldVideoIntro) {
		fields = append(fields, videometadatum.FieldVideoIntro)
	}
	if m.FieldCleared(videometadatum.FieldCreateTime) {
		fields = append(fields, videometadatum.FieldCreateTime)
	}
	if m.FieldCleared(videometadatum.FieldUpdateTime) {
		fields = append(fields, videometadatum.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMetadatumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMetadatumMutation) ClearField(name string) error {
	switch name {
	case videometadatum.FieldVideoIntro:
		m.ClearVideoIntro()
		return nil
	case videometadatum.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case videometadatum.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoMetadatum nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMetadatumMutation) ResetField(name string) error {
	switch name {
	case videometadatum.FieldVideoID:
		m.ResetVideoID()
		return nil
	case videometadatum.FieldUserID:
		m.ResetUserID()
		return nil
	case videometadatum.FieldCoverURL:
		m.ResetCoverURL()
		return nil
	case videometadatum.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case videometadatum.FieldVideoIntro:
		m.ResetVideoIntro()
		return nil
	case videometadatum.FieldVideoType:
		m.ResetVideoType()
		return nil
	case videometadatum.FieldPublishAddress:
		m.ResetPublishAddress()
		return nil
	case videometadatum.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case videometadatum.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown VideoMetadatum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMetadatumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMetadatumMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMetadatumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMetadatumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMetadatumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMetadatumMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMetadatumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VideoMetadatum unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMetadatumMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VideoMetadatum edge %s", name)
}
